package modelrailway.util;

import java.util.*;

import modelrailway.core.*;
import modelrailway.core.Event.Listener;
import modelrailway.core.Event.TurnoutChanged;

/**
 * A very simplistic implementation of the controller interface. This tracks
 * trains as they progress on specific routes through sections. Every train must
 * acquire the lock for a given section before it can enter it. This ensures
 * that no two trains are ever in the same section at the same time.
 * 
 * @author David J. Pearce
 *
 */
public class SimpleController implements Controller {
	/**
	 * The set of listeners for events generated by this controller.
	 */
	private ArrayList<Event.Listener> listeners = new ArrayList<Event.Listener>();
	
	/**
	 * The current trains being tracked on the network. Each train records which
	 * section it is currently on.
	 */
	private Train[] trains;
	
	/**
	 * The current routes each train is taking. A route is essentially a
	 * sequence of sections linked together. They can be null if the train is
	 * stopped and not currently following a route.
	 */
	private Route[] routes;
	
	/**
	 * The topology of the rail network. Each section knows the possible routes
	 * between sections.
	 */
	private Section[] sections;
		
	public SimpleController(Train[] trains, Section[] sections) {
		this.routes = new Route[trains.length];
		this.trains = trains;
		this.sections = sections;
	}
	
	@Override
	public void register(Listener listener) {
		listeners.add(listener);
	}
	
	@Override
	public Train train(int trainID) {
		return trains[trainID];
	}

	@Override
	public boolean start(int trainID, Route route) {
		Train train = trains[trainID];
		// First, check whether the route is valid and the train is on the
		// starting section.
		if (isValid(route) && route.firstSection() == train.currentSection()) {
			// Yes, route is valid and train is on the starting section.
			routes[trainID] = route;
			// Attempt to lock the next section in route.
			if(acquireSectionLock(trainID)) {
				// Ok, we have the lock so now start the train moving!
				System.out.println("ACQUIRED LOCK - " + trainID);
				trainAcquiredLock(trainID);
			} else {
				// In this case, the train has started on its route correctly
				// but is now immediately waiting to acquire the lock for the
				// next section.  Therefore, it cannot actually begin yet.
			}
			return true;
		} else {
			// Something went wrong, so stop the train.
			routes[trainID] = null;
			stop(trainID);
			return false;
		}
	}

	@Override
	public void stop(int trainID) {
		send(new Event.SpeedChanged(trainID,0.0f));
	}


	@Override
	public void set(int turnoutID, boolean thrown) {
		send(new Event.TurnoutChanged(turnoutID,thrown));
	}
	
	@Override
	public synchronized void notify(Event e) {
		// This function listens only to section changed events and makes sure
		// that the trains are progressing correctly along each section in their
		// route.
		if(e instanceof Event.SectionChanged) {
			Event.SectionChanged es = (Event.SectionChanged) e;
			// The following calculation assumes that each detection section is
			// an odd number, and that we have alternative
			// detection/non-detection sections.
			int section = 1 + ((es.getSection()-1) * 2);
			// At this point, there are two things to do. Firstly, we need to
			// confirm that this section changed event was the expected event
			// for a route.  Second, we need to update the train with its
			// current predicted section location.
			int trainID = determineTrainFromSectionChange(section, es.getInto());
						
			if(trainID == -1) {
				// this indicates a recognition failure. At this point, we just
				// stop all trains as a simplistic emergency procedure.
				emergencyStopAll();
			} else {
				updateAfterSectionChanged(trainID);
			}
		}
	}
	
	/**
	 * Force all trains on the network to perform an emergency stop.
	 */
	private void emergencyStopAll() {
		System.out.println("INVOKING EMERGENCY STOP");
		for(int i=0;i!=trains.length;++i) {
			routes[i] = null;
			send(new Event.EmergencyStop(i));
		}
	}	
	
	/**
	 * <p>
	 * Update the model after a section changed event for a given train. What we
	 * know at this point is that the train has crossed the boundary between the
	 * section it is currently in, and the next section in its declared route.
	 * </p>
	 * <p>
	 * What we need to do here is to, firstly, update the current location of
	 * the train recorded in the model. Furthermore, if this section is the last
	 * section of its route, then we should stop the train. Otherwise, we must
	 * attempt to lock the next section in its route. If we can obtain the lock,
	 * then all is well and the train can continue. If we can't obtain the lock,
	 * we need to stop the train and wait for the lock to be released. Finally,
	 * we need to release one or more locks on sections previously held by this
	 * train.
	 * </p>
	 * 
	 * @param trainID
	 */
	private void updateAfterSectionChanged(int trainID) {
		// First, determine the next section in this train's route.
		Train train = trains[trainID];
		Route route = routes[trainID];
		int prevSection = train.currentSection();
		Integer current = route.nextSection(prevSection);
		
		if(current == null) {
			// This indicates something went wrong. It should essentially be
			// impossible to get here. 
			emergencyStopAll();
		} else {
			// Found the next section, so update the train's current location to
			// it. This is because the train has moved from the section it was
			// in to this section.
			train.setSection(current);
			// Now, release and locked sections that have become available.
			releaseLockedSections(trainID);
			// Finally, decide what to do next.
			if(current == route.lastSection()) {
				// The train has reached the last section of its route,
				// therefore we stop the train.
				stop(trainID);
			} else {				
				// The train has not reached the last section of its route.
				// Therefore, we need to acquire the lock for the subsequent
				// section in the route.
				acquireSectionLock(trainID);
				
			}
		}
	}

	/**
	 * The given train has moved from the previous section in its route to the
	 * current section. Therefore, one or more sections may have become
	 * available and can be released. In doing so, there may be one or more
	 * other trains which can acquire that lock and proceed with their journey.
	 * 
	 * @param trainID
	 */
	private void releaseLockedSections(int trainID) {		
		Train train = trains[trainID];
		Route route = routes[trainID];
		int prevSection = route.prevSection(train.currentSection());
		System.out.println("RELEASING LOCK: " + prevSection + "(train: " + trainID + ")");
		Section section = sections[prevSection];
		// TODO: for now, I'm just going to always release the previous section
		// in the route. This is clearly unsafe as it's essentially assuming the
		// train has no length (which clearly it does).
		section.unlock(trainID);
		// Now, see whether there are any trains which are queued waiting for
		// this lock.
		int nextQueuedTrain = section.nextQueued();
		if (nextQueuedTrain != -1) {
			// Ok, this train now has the lock for that section and can proceed.
			trainAcquiredLock(nextQueuedTrain);
		}
	}
	
	/**
	 * Attempt to qcquire the lock for the next section in the given train's
	 * route. If this lock can be acquired, then all is well and the train may
	 * continue as normal. Otherwise, the train must wait until the lock for
	 * that section becomes available.
	 * 
	 * @param trainID
	 */
	private boolean acquireSectionLock(int trainID) {
		Train train = trains[trainID];
		Route route = routes[trainID];
		int currentSection = train.currentSection();
		int nextSection = route.nextSection(currentSection);
		Integer nextNextSection = route.nextSection(nextSection);
		System.out.print("ATTEMPTING TO ACQUIRE LOCK - " + nextNextSection + "(train: " + trainID + ") ... ");
		Section section = sections[nextSection];
		if(section.lock(trainID, currentSection, nextNextSection)) {
			// Yes, we managed to acquire the lock --- so we must now configure
			// the section and everything can continue as normal.
			if(nextNextSection != null) {
				// FIXME: what happens in the case of terminating in a section
				// is really a bug I think.
				configureSection(section,currentSection,nextNextSection);
			}
			System.out.println("[OK]");
			return true;
		} else {
			// No, we couldn't acquire the lock. This means the train is
			// now queued waiting to acquire this lock. In the
			// meantime, we must stop the train to prevent a potential
			// accident!
			stop(trainID);
			System.out.println("[FAILED]");
			return false;
		}
	}

	/**
	 * The train has now acquired the lock to the next section in its route. The
	 * assumption is that, at this point, the train is standing still waiting
	 * for the lock.  Therefore, the train should begin on its way!
	 * 
	 * @param trainID
	 */
	public void trainAcquiredLock(int trainID) {
		// In the simple controller, trains always move in the forwards
		// direction. This is necessary because the controller has no
		// knowledge of the network topology and cannot make any
		// distinctions about what directions make sense.
		send(new Event.DirectionChanged(trainID, true));
		// In the simple controller, trains always move at a fixed velocity.
		send(new Event.SpeedChanged(trainID, 0.75f));
	}
	
	/**
	 * Go through the turnout configuration for the given section and apply it.
	 * This means signalling to the hardware the setting for each turnout in the
	 * section.
	 * 
	 * @param section
	 *            --- Section to be configured
	 * @param entry
	 *            -- entry point to that section
	 * @param exit
	 *            -- exit point to that section
	 */
	public void configureSection(Section section, int entry, int exit) {
		Map<Integer,Boolean> config = section.getTurnoutConfiguration(entry, exit);
		for(Map.Entry<Integer,Boolean> p : config.entrySet()) {
			set(p.getKey(),p.getValue());
		}
	}
	
	/**
	 * Determine whether a given route is valid or not. For a route to be
	 * considered valid it must be possible to traverse each section, starting
	 * from the beginning, to reach the next section in the route.
	 * 
	 * @param r
	 * @return
	 */
	private boolean isValid(Route r) {
		Integer prev = null;
		int current = r.firstSection();
		Integer next = r.nextSection(current);
		while (current != r.lastSection()) {
			Section section = sections[current];
			if (prev != null && !section.isValidConfiguration(prev, next)) {
				return false;
			}
			prev = current;
			current = r.nextSection(current);
			next = r.nextSection(current);
		}
		return true;
	}

	/**
	 * Given a section changed event, attempt to determine which train caused
	 * the event. There are two kinds of events: rising-edge and falling edge. A
	 * rising edge event occurs when a train enters a detection section, as the
	 * detector goes from low to high. A falling edge event occurs when a train
	 * leaves a detection section, as the detector goes from high to low.
	 * 
	 * @param section
	 *            The section number which triggered this event. This is
	 *            normalised to be in the section space of the model, rather
	 *            than the hardware.
	 * @param risingEdge
	 *            True if this is a risingEdge event, or false otherwise.
	 * @return The train id matching this event, or -1 if no such train was
	 *         found.
	 */
	private int determineTrainFromSectionChange(int section, boolean risingEdge) {
		if (risingEdge) {
			// This indicates that a train has moved into a new detection
			// section. To figure out which train, we need to look at the
			// next expected section for each train to see whether it
			// matches any of them.
			for (int i = 0; i != trains.length; ++i) {
				Route route = routes[i];
				if (route != null) {
					Integer expected = route.nextSection(trains[i]
							.currentSection());
					if (expected != null && expected == section) {
						// Matched
						// System.out.println("MATCHED TRAIN " + i +
						// " ENTERING SECTION " + section);
						return i;
					}
				}
			}
		} else {
			// This indicates that a train has moved out of a given
			// detection section. To figure out which train, we need simply
			// need to decide which train was in that section.
			for (int i = 0; i != trains.length; ++i) {
				if (trains[i].currentSection() == section) {
					// Matched
					// System.out.println("MATCHED TRAIN " + i +
					// " LEAVING SECTION " + section);
					return i;
				}
			}
		}
		// Unable to detect
		return -1;
	}
	

	/**
	 * A helper function for broadcasting events to all registered listeners.
	 * 
	 * @param e
	 */
	private void send(Event e) {
		for(Listener l : listeners) {
			l.notify(e);
		}
	}
}
