package modelrailway.util;

import java.util.*;

import modelrailway.core.*;
import modelrailway.core.Event.Listener;
import modelrailway.core.Event.TurnoutChanged;

/**
 * A very simplistic implementation of the controller interface. This manages
 * trains as they progress through specific routes. 
 * 
 * @author David J. Pearce
 *
 */
public class SimpleController implements Controller {
	/**
	 * The set of listeners for events generated by this controller.
	 */
	private ArrayList<Event.Listener> listeners = new ArrayList<Event.Listener>();
	
	/**
	 * The current trains being tracked on the network.
	 */
	private Train[] trains;
	
	/**
	 * The current routes each train is taking. A route is essentially a
	 * sequence of sections linked together. They can be null if the train is
	 * stopped and not currently following a route.
	 */
	private Route[] routes;
	
	/**
	 * The topology of the rail network. Each section knows the possible routes
	 * between sections.
	 */
	private Section[] sections;
		
	public SimpleController(Train[] trains, Section[] sections) {
		this.routes = new Route[trains.length];
		this.trains = trains;
		this.sections = sections;
	}
	
	@Override
	public void register(Listener listener) {
		listeners.add(listener);
	}
	
	@Override
	public Train train(int trainID) {
		return trains[trainID];
	}

	@Override
	public boolean start(int trainID, Route route) {
		Train train = trains[trainID];
		if (isValid(route) && route.firstSection() == train.currentSection()) {
			// Yes, route is valid and train is on the starting section.
			routes[trainID] = route;
			// Attempt to lock next section in route.
			int current = route.firstSection();
			int next = route.nextSection(route.firstSection());
			Integer nextnext = route.nextSection(next);
			if(sections[next].lockRoute(trainID, current, nextnext)) {
				// In the simple controller, trains always move in the forwards
				// direction. This is necessary because the controller has no
				// knowledge of the network topology and cannot make any
				// distinctions about what directions make sense.
				send(new Event.DirectionChanged(trainID, true));
				// In the simple controller, trains always move at a fixed velocity.
				send(new Event.SpeedChanged(trainID, 0.75f));
			} else {
				// In this case, the train has started correctly but is now
				// immediately waiting.
			}
			return true;
		} 
		routes[trainID] = null;
		stop(trainID);
		return false;
	}

	@Override
	public void stop(int trainID) {
		send(new Event.SpeedChanged(trainID,0.0f));		
	}


	@Override
	public void set(int turnoutID, boolean thrown) {
		send(new Event.TurnoutChanged(turnoutID,thrown));
	}
	
	@Override
	public synchronized void notify(Event e) {
		// This function listens only to section changed events and makes sure
		// that the trains are progressing correctly along each section in their
		// route.
		if(e instanceof Event.SectionChanged) {
			Event.SectionChanged es = (Event.SectionChanged) e;
			// The following calculation assumes that each detection section is
			// an odd number, and that we have alternative
			// detection/non-detection sections.
			int section = 1 + ((es.getSection()-1) * 2);
			// At this point, there are two things to do. Firstly, we need to
			// confirm that this section changed event was the expected event
			// for a route.  Second, we need to update the train with its
			// current predicted section location.
			int trainID = -1;

			if(es.getInto()) {
				// This indicates that a train has moved into a new detection
				// section. To figure out which train, we need to look at the
				// next expected section for each train to see whether it
				// matches any of them.
				for(int i=0;i!=trains.length;++i) {
					Route route = routes[i];
					if(route != null) {
						Integer expected = route.nextSection(trains[i].currentSection());
						if (expected != null && expected == section) {
							// Matched
							//System.out.println("MATCHED TRAIN " + i + " ENTERING SECTION " + section);
							trainID = i;
							break;
						}
					}
				}
			} else {
				// This indicates that a train has moved out of a given
				// detection section. To figure out which train, we need simply
				// need to decide which train was in that section.
				for(int i=0;i!=trains.length;++i) {
					if(trains[i].currentSection() == section) {
						// Matched
						//System.out.println("MATCHED TRAIN " + i + " LEAVING SECTION " + section);
						trainID = i;
						break;
					}
				}
			}
			
			if(trainID == -1) {
				// this indicates a recognition failure. At this point, we just
				// stop all trains as a simplistic emergency procedure.
				//emergencyStopAll();
			} else {
				// We managed to determine which train caused this event,
				// therefore we now update it's position.
				Train train = trains[trainID];
				Route route = routes[trainID];
				Integer nextSection = route.nextSection(train.currentSection());
				if(nextSection == null) {
					// This indicates something went wrong.
					emergencyStopAll();
				} else {
					train.setSection(nextSection);
					if(nextSection == route.lastSection()) {
						// The train has reached the last section of its route.
						stop(trainID);
						routes[trainID] = null;
					}					
				}
			}
		}
	}
	
	private void emergencyStopAll() {
		System.out.println("INVOKING EMERGENCY STOP");
		for(int i=0;i!=trains.length;++i) {
			routes[i] = null;
			send(new Event.EmergencyStop(i));
		}
	}
	
	/**
	 * A helper function for broadcasting events to all registered listeners.
	 * 
	 * @param e
	 */
	private void send(Event e) {
		for(Listener l : listeners) {
			l.notify(e);
		}
	}
	
	private boolean isValid(Route r) {
		Integer prev = null;
		int current = r.firstSection();
		Integer next = r.nextSection(current);
		while (current != r.lastSection()) {
			Section section = sections[current];
			if (prev != null && !section.isValidRoute(prev, next)) {
				return false;
			}
			prev = current;
			current = r.nextSection(current);
			next = r.nextSection(current);
		}
		return true;
	}
}
